{"version":3,"sources":["../node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs","../node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs","../node_modules/framer-motion/dist/es/utils/use-force-update.mjs"],"names":["presenceId","getPresenceId","id","PresenceChild","_a","children","initial","isPresent","onExitComplete","custom","presenceAffectsLayout","presenceChildren","useConstant","newChildrenMap","context","useMemo","childId","e_1","set","_b","__values","values","_c","next","done","value","e_1_1","error","return","call","register","delete","undefined","forEach","_","key","React","size","PresenceContext","Provider","Map","getChildKey","child","AnimatePresence","exitBeforeEnter","_d","__read","isUnmountingRef","useRef","useState","forcedRenderCount","setForcedRenderCount","useUnmountEffect","current","forceRender","useCallback","sync","postRender","useForceUpdate","forceRenderLayoutGroup","useContext","LayoutGroupContext","isInitialRender","isMounted","useEffect","filteredChildren","filtered","Children","isValidElement","push","onlyElements","presentChildren","allChildren","exiting","Set","updateChildLookup","map","childrenToRender","__spreadArray","presentKeys","targetKeys","numPresent","length","i","indexOf","add","get","insertionIndex","splice","removeIndex","findIndex","presentChild","has","cloneElement"],"mappings":"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","file":"static/js/13.f53fcbb4.chunk.js","sourcesContent":["import { __values } from 'tslib';\nimport * as React from 'react';\nimport { useMemo } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\n\nvar presenceId = 0;\nfunction getPresenceId() {\n    var id = presenceId;\n    presenceId++;\n    return id;\n}\nvar PresenceChild = function (_a) {\n    var children = _a.children, initial = _a.initial, isPresent = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom, presenceAffectsLayout = _a.presenceAffectsLayout;\n    var presenceChildren = useConstant(newChildrenMap);\n    var id = useConstant(getPresenceId);\n    var context = useMemo(function () { return ({\n        id: id,\n        initial: initial,\n        isPresent: isPresent,\n        custom: custom,\n        onExitComplete: function (childId) {\n            var e_1, _a;\n            presenceChildren.set(childId, true);\n            try {\n                for (var _b = __values(presenceChildren.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var isComplete = _c.value;\n                    if (!isComplete)\n                        return; // can stop searching when any is incomplete\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete();\n        },\n        register: function (childId) {\n            presenceChildren.set(childId, false);\n            return function () { return presenceChildren.delete(childId); };\n        },\n    }); }, \n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    presenceAffectsLayout ? undefined : [isPresent]);\n    useMemo(function () {\n        presenceChildren.forEach(function (_, key) { return presenceChildren.set(key, false); });\n    }, [isPresent]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(function () {\n        !isPresent && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n    }, [isPresent]);\n    return (React.createElement(PresenceContext.Provider, { value: context }, children));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\nexport { PresenceChild };\n","import { __read, __spreadArray } from 'tslib';\nimport * as React from 'react';\nimport { useContext, useRef, useEffect, cloneElement, Children, isValidElement } from 'react';\nimport { useForceUpdate } from '../../utils/use-force-update.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\n\nfunction getChildKey(child) {\n    return child.key || \"\";\n}\nfunction updateChildLookup(children, allChildren) {\n    var seenChildren = process.env.NODE_ENV !== \"production\" ? new Set() : null;\n    children.forEach(function (child) {\n        var key = getChildKey(child);\n        if (process.env.NODE_ENV !== \"production\" && seenChildren) {\n            if (seenChildren.has(key)) {\n                console.warn(\"Children of AnimatePresence require unique keys. \\\"\".concat(key, \"\\\" is a duplicate.\"));\n            }\n            seenChildren.add(key);\n        }\n        allChildren.set(key, child);\n    });\n}\nfunction onlyElements(children) {\n    var filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, function (child) {\n        if (isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nvar AnimatePresence = function (_a) {\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter, _c = _a.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;\n    // We want to force a re-render once all exiting animations have finished. We\n    // either use a local forceRender function, or one from a parent context if it exists.\n    var _d = __read(useForceUpdate(), 1), forceRender = _d[0];\n    var forceRenderLayoutGroup = useContext(LayoutGroupContext).forceRender;\n    if (forceRenderLayoutGroup)\n        forceRender = forceRenderLayoutGroup;\n    var isInitialRender = useRef(true);\n    var isMounted = useRef(true);\n    useEffect(function () { return function () {\n        isMounted.current = false;\n    }; }, []);\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n    var filteredChildren = onlyElements(children);\n    // Keep a living record of the children we're actually rendering so we\n    // can diff to figure out which are entering and exiting\n    var presentChildren = useRef(filteredChildren);\n    // A lookup table to quickly reference components by key\n    var allChildren = useRef(new Map()).current;\n    // A living record of all currently exiting components.\n    var exiting = useRef(new Set()).current;\n    updateChildLookup(filteredChildren, allChildren);\n    // If this is the initial component render, just deal with logic surrounding whether\n    // we play onMount animations or not.\n    if (isInitialRender.current) {\n        isInitialRender.current = false;\n        return (React.createElement(React.Fragment, null, filteredChildren.map(function (child) { return (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout }, child)); })));\n    }\n    // If this is a subsequent render, deal with entering and exiting children\n    var childrenToRender = __spreadArray([], __read(filteredChildren), false);\n    // Diff the keys of the currently-present and target children to update our\n    // exiting list.\n    var presentKeys = presentChildren.current.map(getChildKey);\n    var targetKeys = filteredChildren.map(getChildKey);\n    // Diff the present children with our target children and mark those that are exiting\n    var numPresent = presentKeys.length;\n    for (var i = 0; i < numPresent; i++) {\n        var key = presentKeys[i];\n        if (targetKeys.indexOf(key) === -1) {\n            exiting.add(key);\n        }\n        else {\n            // In case this key has re-entered, remove from the exiting list\n            exiting.delete(key);\n        }\n    }\n    // If we currently have exiting children, and we're deferring rendering incoming children\n    // until after all current children have exiting, empty the childrenToRender array\n    if (exitBeforeEnter && exiting.size) {\n        childrenToRender = [];\n    }\n    // Loop through all currently exiting components and clone them to overwrite `animate`\n    // with any `exit` prop they might have defined.\n    exiting.forEach(function (key) {\n        // If this component is actually entering again, early return\n        if (targetKeys.indexOf(key) !== -1)\n            return;\n        var child = allChildren.get(key);\n        if (!child)\n            return;\n        var insertionIndex = presentKeys.indexOf(key);\n        var onExit = function () {\n            allChildren.delete(key);\n            exiting.delete(key);\n            // Remove this child from the present children\n            var removeIndex = presentChildren.current.findIndex(function (presentChild) { return presentChild.key === key; });\n            presentChildren.current.splice(removeIndex, 1);\n            // Defer re-rendering until all exiting children have indeed left\n            if (!exiting.size) {\n                presentChildren.current = filteredChildren;\n                if (isMounted.current === false) {\n                    return;\n                }\n                forceRender();\n                onExitComplete && onExitComplete();\n            }\n        };\n        childrenToRender.splice(insertionIndex, 0, React.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\n    // the same tree between renders\n    childrenToRender = childrenToRender.map(function (child) {\n        var key = child.key;\n        return exiting.has(key) ? (child) : (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    presentChildren.current = childrenToRender;\n    if (process.env.NODE_ENV !== \"production\" &&\n        exitBeforeEnter &&\n        childrenToRender.length > 1) {\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n    }\n    return (React.createElement(React.Fragment, null, exiting.size\n        ? childrenToRender\n        : childrenToRender.map(function (child) { return cloneElement(child); })));\n};\n\nexport { AnimatePresence };\n","import { __read } from 'tslib';\nimport sync from 'framesync';\nimport { useRef, useState, useCallback } from 'react';\nimport { useUnmountEffect } from './use-unmount-effect.mjs';\n\nfunction useForceUpdate() {\n    var isUnmountingRef = useRef(false);\n    var _a = __read(useState(0), 2), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];\n    useUnmountEffect(function () { return (isUnmountingRef.current = true); });\n    var forceRender = useCallback(function () {\n        !isUnmountingRef.current && setForcedRenderCount(forcedRenderCount + 1);\n    }, [forcedRenderCount]);\n    /**\n     * Defer this to the end of the next animation frame in case there are multiple\n     * synchronous calls.\n     */\n    var deferredForceRender = useCallback(function () { return sync.postRender(forceRender); }, [forceRender]);\n    return [deferredForceRender, forcedRenderCount];\n}\n\nexport { useForceUpdate };\n"],"sourceRoot":""}